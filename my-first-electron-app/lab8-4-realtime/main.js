const { app, BrowserWindow, ipcMain, Notification, Tray, Menu, nativeImage } = require('electron');
const path = require('path');
const https = require('https');
const fs = require('fs').promises;
const config = require('./api-config');

let mainWindow;
let tray = null;
let settings = {};

// ‡πÇ‡∏´‡∏•‡∏î settings
async function loadSettings() {
  try {
    const data = await fs.readFile('settings.json', 'utf8');
    settings = JSON.parse(data);
    console.log('‚öôÔ∏è [MAIN] ‡πÇ‡∏´‡∏•‡∏î settings ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
  } catch (error) {
    console.log('‚öôÔ∏è [MAIN] ‡πÉ‡∏ä‡πâ default settings');
    settings = {
      theme: 'dark',
      autoRefresh: false,
      notifications: true,
      soundEnabled: false,
      refreshInterval: 30000
    };
  }
}

// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å settings
async function saveSettings() {
  try {
    await fs.writeFile('settings.json', JSON.stringify(settings, null, 2));
    console.log('üíæ [MAIN] ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å settings ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
  } catch (error) {
    console.error('‚ùå [MAIN] ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å settings ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß:', error);
  }
}

function createWindow() {
  console.log('üöÄ [MAIN] ‡∏™‡∏£‡πâ‡∏≤‡∏á Real-time Wallboard...');
  
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    },
    title: 'Agent Wallboard - Real-time Dashboard',
    icon: path.join(__dirname, 'assets/icon.png')
  });

  mainWindow.loadFile('index.html');
  
  // ‡πÄ‡∏õ‡∏¥‡∏î DevTools ‡πÉ‡∏ô‡πÇ‡∏´‡∏°‡∏î development
  if (process.env.NODE_ENV === 'development') {
    mainWindow.webContents.openDevTools();
  }
  
  console.log('‚úÖ [MAIN] Wallboard ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÅ‡∏•‡πâ‡∏ß');
}

// ‡∏™‡∏£‡πâ‡∏≤‡∏á System Tray
function createTray() {
  try {
    const iconPath = path.join(__dirname, 'assets/tray-icon.png');
    const trayIcon = nativeImage.createFromPath(iconPath);
    
    tray = new Tray(trayIcon.resize({ width: 16, height: 16 }));
    
    const contextMenu = Menu.buildFromTemplate([
      {
        label: '‡πÅ‡∏™‡∏î‡∏á Dashboard',
        click: () => {
          if (mainWindow) {
            mainWindow.show();
            mainWindow.focus();
          }
        }
      },
      {
        label: '‡∏ã‡πà‡∏≠‡∏ô',
        click: () => {
          if (mainWindow) {
            mainWindow.hide();
          }
        }
      },
      { type: 'separator' },
      {
        label: '‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°',
        click: () => {
          app.quit();
        }
      }
    ]);
    
    tray.setToolTip('Agent Wallboard');
    tray.setContextMenu(contextMenu);
    
    tray.on('double-click', () => {
      if (mainWindow) {
        mainWindow.show();
        mainWindow.focus();
      }
    });
    
    console.log('üìå [MAIN] System Tray ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô');
  } catch (error) {
    console.warn('‚ö†Ô∏è [MAIN] ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á System Tray ‡πÑ‡∏î‡πâ:', error.message);
  }
}

// ===== HTTP API FUNCTIONS =====

function callAPI(url, options = {}) {
  return new Promise((resolve, reject) => {
    console.log('üåê [MAIN] ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å API:', url);
    
    const requestOptions = {
      headers: {
        'User-Agent': 'Agent-Wallboard/1.0',
        ...options.headers
      },
      timeout: 10000
    };
    
    https.get(url, requestOptions, (response) => {
      let data = '';
      
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö status code
      if (response.statusCode !== 200) {
        reject(new Error(`HTTP ${response.statusCode}: ${response.statusMessage}`));
        return;
      }
      
      response.on('data', (chunk) => {
        data += chunk;
      });
      
      response.on('end', () => {
        try {
          const jsonData = JSON.parse(data);
          console.log('‚úÖ [MAIN] API ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
          resolve(jsonData);
        } catch (error) {
          console.error('‚ùå [MAIN] Parse error:', error);
          reject(new Error('Invalid JSON response'));
        }
      });
      
    }).on('error', (error) => {
      console.error('‚ùå [MAIN] API error:', error);
      reject(error);
    }).on('timeout', () => {
      console.error('‚ùå [MAIN] API timeout');
      reject(new Error('Request timeout'));
    });
  });
}

// ===== ALTERNATIVE TIME APIS =====

// ‡πÉ‡∏ä‡πâ WorldTimeAPI.org (‡∏ü‡∏£‡∏µ, ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ key)
function getWorldTimeAlternative() {
  return new Promise((resolve, reject) => {
    const url = 'https://worldtimeapi.org/api/timezone/Asia/Bangkok';
    console.log('üïí [MAIN] ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å WorldTimeAPI...');
    
    https.get(url, (response) => {
      let data = '';
      
      if (response.statusCode !== 200) {
        reject(new Error(`WorldTimeAPI Error: ${response.statusCode}`));
        return;
      }
      
      response.on('data', (chunk) => {
        data += chunk;
      });
      
      response.on('end', () => {
        try {
          const timeData = JSON.parse(data);
          console.log('‚úÖ [MAIN] WorldTimeAPI ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
          resolve(timeData);
        } catch (error) {
          console.error('‚ùå [MAIN] WorldTimeAPI Parse error:', error);
          reject(error);
        }
      });
      
    }).on('error', (error) => {
      console.error('‚ùå [MAIN] WorldTimeAPI error:', error);
      reject(error);
    });
  });
}

// ‡πÉ‡∏ä‡πâ API.time.ly (‡∏ü‡∏£‡∏µ)
function getTimeLyAPI() {
  return new Promise((resolve, reject) => {
    const url = 'https://timeapi.io/api/Time/current/zone?timeZone=Asia/Bangkok';
    console.log('üïí [MAIN] ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å TimeLy API...');
    
    https.get(url, (response) => {
      let data = '';
      
      if (response.statusCode !== 200) {
        reject(new Error(`TimeLy API Error: ${response.statusCode}`));
        return;
      }
      
      response.on('data', (chunk) => {
        data += chunk;
      });
      
      response.on('end', () => {
        try {
          const timeData = JSON.parse(data);
          console.log('‚úÖ [MAIN] TimeLy API ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
          resolve(timeData);
        } catch (error) {
          console.error('‚ùå [MAIN] TimeLy API Parse error:', error);
          reject(error);
        }
      });
      
    }).on('error', (error) => {
      console.error('‚ùå [MAIN] TimeLy API error:', error);
      reject(error);
    });
  });
}

// ===== ADVANCED ERROR HANDLING =====

function callAPIWithRetry(url, maxRetries = 3, delay = 1000) {
  return new Promise(async (resolve, reject) => {
    let lastError;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`üîÅ [MAIN] ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÄ‡∏£‡∏µ‡∏¢‡∏Å API (‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà ${attempt}/${maxRetries})...`);
        const result = await callAPI(url);
        console.log(`‚úÖ [MAIN] API ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡πÉ‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà ${attempt}`);
        resolve(result);
        return;
      } catch (error) {
        lastError = error;
        console.warn(`‚ö†Ô∏è [MAIN] API ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà ${attempt}:`, error.message);
        
        if (attempt < maxRetries) {
          console.log(`‚è≥ [MAIN] ‡∏£‡∏≠ ${delay}ms ‡∏Å‡πà‡∏≠‡∏ô‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà...`);
          await new Promise(resolve => setTimeout(resolve, delay));
          delay *= 2;
        }
      }
    }
    
    reject(lastError);
  });
}

// ===== NOTIFICATION SYSTEM =====

function showDesktopNotification(title, body, agentId = null) {
  if (!Notification.isSupported()) {
    console.log('üîî [MAIN] Desktop notifications ‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏ö‡∏ô platform ‡∏ô‡∏µ‡πâ');
    return;
  }
  
  if (settings.notifications !== false) {
    const notification = new Notification({
      title: title,
      body: body,
      icon: path.join(__dirname, 'assets/notification-icon.png'),
      silent: settings.soundEnabled === false
    });
    
    notification.show();
    
    notification.on('click', () => {
      if (mainWindow) {
        mainWindow.show();
        mainWindow.focus();
      }
    });
    
    console.log(`üîî [MAIN] ‡∏™‡πà‡∏á notification: ${title}`);
  }
}

// ===== IPC HANDLERS =====

// üïí ‡∏î‡∏∂‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏à‡∏≤‡∏Å World Time API (‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÅ‡∏•‡πâ‡∏ß)
ipcMain.handle('get-world-time', async () => {
  try {
    console.log('üïí [MAIN] ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏î‡∏∂‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏à‡∏≤‡∏Å API ‡∏ï‡πà‡∏≤‡∏á‡πÜ...');
    
    // ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ WorldTimeAPI.org ‡∏Å‡πà‡∏≠‡∏ô (‡∏ü‡∏£‡∏µ, ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ key)
    try {
      const timeData = await getWorldTimeAlternative();
      const thaiTime = new Date(timeData.datetime).toLocaleString('th-TH', {
        timeZone: 'Asia/Bangkok',
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
      });
      
      return {
        success: true,
        datetime: timeData.datetime,
        timezone: timeData.timezone,
        formatted: thaiTime,
        source: 'WorldTimeAPI.org'
      };
    } catch (firstError) {
      console.log('‚ö†Ô∏è [MAIN] WorldTimeAPI.org ‡πÑ‡∏°‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô, ‡∏•‡∏≠‡∏á API ‡∏≠‡∏∑‡πà‡∏ô...');
      
      // ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ Time.ly API
      try {
        const timeData = await getTimeLyAPI();
        const date = new Date();
        const datetime = date.toISOString();
        const thaiTime = date.toLocaleString('th-TH', {
          timeZone: 'Asia/Bangkok',
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          hour12: false
        });
        
        return {
          success: true,
          datetime: datetime,
          timezone: 'Asia/Bangkok',
          formatted: thaiTime,
          source: 'Time.ly API'
        };
      } catch (secondError) {
        console.log('‚ö†Ô∏è [MAIN] Time.ly API ‡πÑ‡∏°‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô...');
        throw new Error('‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î API ‡πÑ‡∏°‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô: ' + firstError.message + ' | ' + secondError.message);
      }
    }

  } catch (error) {
    console.error('‚ùå [MAIN] Time API error ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î:', error);
    const fallbackTime = new Date().toLocaleString('th-TH', {
      timeZone: 'Asia/Bangkok',
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false
    });
    
    return {
      success: false,
      error: error.message,
      fallback: fallbackTime,
      source: 'Local System'
    };
  }
});

// üïí ‡∏î‡∏∂‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏à‡∏≤‡∏Å World Time API (‡∏û‡∏£‡πâ‡∏≠‡∏° Retry)
ipcMain.handle('get-world-time-retry', async () => {
  try {
    console.log('üïí [MAIN] ‡∏î‡∏∂‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏à‡∏≤‡∏Å API (‡∏û‡∏£‡πâ‡∏≠‡∏° retry)...');
    
    // ‡πÉ‡∏ä‡πâ WorldTimeAPI.org ‡∏û‡∏£‡πâ‡∏≠‡∏° retry
    const timeData = await callAPIWithRetry('https://worldtimeapi.org/api/timezone/Asia/Bangkok', 3, 1000);
    const thaiTime = new Date(timeData.datetime).toLocaleString('th-TH', {
      timeZone: 'Asia/Bangkok',
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false
    });

    return {
      success: true,
      datetime: timeData.datetime,
      timezone: timeData.timezone,
      formatted: thaiTime,
      retryUsed: true,
      source: 'WorldTimeAPI.org (Retry)'
    };

  } catch (error) {
    console.error('‚ùå [MAIN] Time API error ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å retry:', error);
    const fallbackTime = new Date().toLocaleString('th-TH', {
      timeZone: 'Asia/Bangkok',
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false
    });
    
    return {
      success: false,
      error: error.message,
      fallback: fallbackTime,
      retryFailed: true,
      source: 'Local System'
    };
  }
});

// üìä ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• mock users (‡∏à‡∏≥‡∏•‡∏≠‡∏á agents)
ipcMain.handle('get-mock-agents', async () => {
  try {
    console.log('üìä [MAIN] ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• mock agents...');
    const users = await callAPI(config.usersAPI);
    
    // ‡∏™‡∏∏‡πà‡∏°‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
    const agents = users.slice(0, 8).map((user, index) => {
      const statuses = ['Available', 'Busy', 'Break', 'Offline'];
      const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];
      const callsToday = Math.floor(Math.random() * 20) + 1;
      const avgCallTime = Math.floor(Math.random() * 300) + 60;
      
      return {
        id: `AG${String(index + 1).padStart(3, '0')}`,
        name: user.name,
        email: user.email,
        phone: user.phone,
        status: randomStatus,
        extension: `100${index + 1}`,
        company: user.company.name,
        lastUpdate: new Date().toISOString(),
        stats: {
          callsToday: callsToday,
          avgCallTime: avgCallTime,
          totalTalkTime: callsToday * avgCallTime,
          satisfaction: Math.floor(Math.random() * 20) + 80 // 80-100%
        }
      };
    });
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏£‡∏∞‡∏ö‡∏ö
    const systemStats = {
      totalAgents: agents.length,
      availableAgents: agents.filter(a => a.status === 'Available').length,
      busyAgents: agents.filter(a => a.status === 'Busy').length,
      totalCalls: agents.reduce((sum, agent) => sum + agent.stats.callsToday, 0),
      avgWaitTime: Math.floor(Math.random() * 50) + 10,
      serviceLevel: Math.floor(Math.random() * 15) + 85 // 85-100%
    };
    
    return {
      success: true,
      agents: agents,
      systemStats: systemStats,
      count: agents.length,
      timestamp: new Date().toISOString()
    };
    
  } catch (error) {
    console.error('‚ùå [MAIN] Mock agents error:', error);
    
    // Fallback ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    try {
      const mockData = await fs.readFile('mock-data.json', 'utf8');
      const fallbackData = JSON.parse(mockData);
      
      return {
        success: true,
        agents: fallbackData.agents,
        systemStats: fallbackData.systemStats,
        fallback: true,
        error: error.message
      };
    } catch (fallbackError) {
      console.error('‚ùå [MAIN] Fallback data error:', fallbackError);
      
      // Emergency fallback
      return {
        success: true,
        agents: [
          {
            id: 'AG001',
            name: 'Fallback Agent',
            status: 'Available',
            extension: '1001',
            stats: { callsToday: 0, avgCallTime: 0, totalTalkTime: 0 }
          }
        ],
        systemStats: {
          totalAgents: 1,
          availableAgents: 1,
          busyAgents: 0,
          totalCalls: 0,
          avgWaitTime: 0,
          serviceLevel: 0
        },
        emergencyFallback: true,
        error: error.message
      };
    }
  }
});

// üå§Ô∏è ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏® (‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÅ‡∏•‡πâ‡∏ß)
ipcMain.handle('get-weather', async () => {
  try {
    const weatherURL = `${config.weatherAPI}?q=Bangkok,th&appid=${config.weatherKey}&units=metric&lang=th`;
    console.log('üå§Ô∏è [MAIN] ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å Weather API:', weatherURL);
    
    const weatherData = await callAPI(weatherURL);
    
    // ‡πÅ‡∏õ‡∏•‡∏á‡∏™‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢
    const weatherDescriptions = {
      'clear sky': '‡∏ó‡πâ‡∏≠‡∏á‡∏ü‡πâ‡∏≤‡πÅ‡∏à‡πà‡∏°‡πÉ‡∏™',
      'few clouds': '‡∏°‡∏µ‡πÄ‡∏°‡∏Ü‡∏ö‡∏≤‡∏á‡∏™‡πà‡∏ß‡∏ô', 
      'scattered clouds': '‡πÄ‡∏°‡∏Ü‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢',
      'broken clouds': '‡∏°‡∏µ‡πÄ‡∏°‡∏Ü‡∏°‡∏≤‡∏Å',
      'overcast clouds': '‡πÄ‡∏°‡∏Ü‡∏Ñ‡∏£‡∏∂‡πâ‡∏°',
      'light rain': '‡∏ù‡∏ô‡∏ï‡∏Å‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢',
      'moderate rain': '‡∏ù‡∏ô‡∏ï‡∏Å‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á',
      'heavy intensity rain': '‡∏ù‡∏ô‡∏ï‡∏Å‡∏´‡∏ô‡∏±‡∏Å',
      'very heavy rain': '‡∏ù‡∏ô‡∏ï‡∏Å‡∏´‡∏ô‡∏±‡∏Å‡∏°‡∏≤‡∏Å',
      'extreme rain': '‡∏ù‡∏ô‡∏ï‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏£‡∏∏‡∏ô‡πÅ‡∏£‡∏á',
      'thunderstorm': '‡∏û‡∏≤‡∏¢‡∏∏‡∏ù‡∏ô‡∏ü‡πâ‡∏≤‡∏Ñ‡∏∞‡∏ô‡∏≠‡∏á',
      'snow': '‡∏´‡∏¥‡∏°‡∏∞‡∏ï‡∏Å',
      'mist': '‡∏´‡∏°‡∏≠‡∏Å',
      'fog': '‡∏´‡∏°‡∏≠‡∏Å‡∏´‡∏ô‡∏≤',
      'haze': '‡∏´‡∏°‡∏≠‡∏Å‡∏Ñ‡∏ß‡∏±‡∏ô'
    };
    
    const description = weatherData.weather[0].description;
    const thaiDescription = weatherDescriptions[description] || description;
    
    return {
      success: true,
      location: weatherData.name,
      temperature: Math.round(weatherData.main.temp) + '¬∞C',
      description: thaiDescription,
      humidity: weatherData.main.humidity + '%',
      pressure: weatherData.main.pressure + ' hPa',
      windSpeed: (weatherData.wind.speed * 3.6).toFixed(1) + ' km/h', // ‡πÅ‡∏õ‡∏•‡∏á m/s ‡πÄ‡∏õ‡πá‡∏ô km/h
      icon: weatherData.weather[0].icon,
      feelsLike: Math.round(weatherData.main.feels_like) + '¬∞C'
    };
    
  } catch (error) {
    console.error('‚ùå [MAIN] Weather API error:', error);
    return {
      success: false,
      error: error.message,
      fallback: {
        location: '‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û‡∏Ø',
        temperature: '32¬∞C',
        description: '‡∏°‡∏µ‡πÄ‡∏°‡∏Ü‡∏ö‡∏≤‡∏á‡∏™‡πà‡∏ß‡∏ô',
        humidity: '65%',
        pressure: '1013 hPa',
        windSpeed: '5.4 km/h',
        feelsLike: '35¬∞C'
      }
    };
  }
});

// ===== SETTINGS MANAGEMENT =====

ipcMain.handle('get-settings', async () => {
  return settings;
});

ipcMain.handle('save-settings', async (event, newSettings) => {
  settings = { ...settings, ...newSettings };
  await saveSettings();
  
  // ‡∏™‡πà‡∏á event ‡πÑ‡∏õ‡∏¢‡∏±‡∏á renderer ‡∏ß‡πà‡∏≤ settings ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô
  if (mainWindow) {
    mainWindow.webContents.send('settings-changed', settings);
  }
  
  return { success: true };
});

ipcMain.handle('show-notification', async (event, { title, body, agentId }) => {
  showDesktopNotification(title, body, agentId);
  return { success: true };
});

// ===== AGENT STATUS SIMULATOR =====

let agentStatusInterval = null;
let simulationStats = {
  totalChanges: 0,
  lastChange: null,
  agentChanges: {}
};

ipcMain.handle('start-agent-simulator', () => {
  console.log('üé≠ [MAIN] ‡πÄ‡∏£‡∏¥‡πà‡∏° Agent Status Simulator...');
  
  if (agentStatusInterval) {
    clearInterval(agentStatusInterval);
  }
  
  const statuses = ['Available', 'Busy', 'Break', 'Offline'];
  const agentIds = ['AG001', 'AG002', 'AG003', 'AG004', 'AG005', 'AG006', 'AG007', 'AG008'];
  
  agentStatusInterval = setInterval(() => {
    const randomAgent = agentIds[Math.floor(Math.random() * agentIds.length)];
    const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];
    
    // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
    simulationStats.totalChanges++;
    simulationStats.lastChange = new Date().toISOString();
    simulationStats.agentChanges[randomAgent] = (simulationStats.agentChanges[randomAgent] || 0) + 1;
    
    console.log(`üé≠ [SIMULATOR] ${randomAgent} ‚Üí ${randomStatus} (‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏•‡πâ‡∏ß ${simulationStats.totalChanges} ‡∏Ñ‡∏£‡∏±‡πâ‡∏á)`);
    
    // ‡∏™‡πà‡∏á notification
    if (settings.notifications !== false) {
      showDesktopNotification(
        `Agent Status Changed`,
        `${randomAgent} is now ${randomStatus}`,
        randomAgent
      );
    }
    
    // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡∏¢‡∏±‡∏á renderer
    if (mainWindow && !mainWindow.isDestroyed()) {
      mainWindow.webContents.send('agent-status-changed', {
        agentId: randomAgent,
        newStatus: randomStatus,
        timestamp: new Date().toISOString(),
        simulated: true,
        stats: simulationStats
      });
    }
    
  }, 8000); // ‡∏ó‡∏∏‡∏Å 8 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
  
  return { 
    success: true, 
    message: 'Agent Simulator ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß',
    interval: 8000
  };
});

ipcMain.handle('stop-agent-simulator', () => {
  console.log('‚èπÔ∏è [MAIN] ‡∏´‡∏¢‡∏∏‡∏î Agent Status Simulator');
  
  if (agentStatusInterval) {
    clearInterval(agentStatusInterval);
    agentStatusInterval = null;
  }
  
  return { 
    success: true, 
    message: 'Agent Simulator ‡∏´‡∏¢‡∏∏‡∏î‡πÅ‡∏•‡πâ‡∏ß',
    finalStats: simulationStats
  };
});

ipcMain.handle('get-simulation-stats', () => {
  return simulationStats;
});

// ===== APP INITIALIZATION =====

app.whenReady().then(async () => {
  await loadSettings();
  createWindow();
  createTray();
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

app.on('before-quit', async () => {
  await saveSettings();
});